<?php
// $Id$

/**
 * @file
 * It Generates menu links for all selected taxonomy terms 
 * 
 * @author Neil Hastings      <http://drupal.org/user/245817>
 * @author Mark Theunissen    <http://drupal.org/user/108606>
 * @author Afief Halumi       <http://drupal.org/user/237472>
 */

//include the database layer
require_once(drupal_get_path('module', 'taxonomy_menu') .'/taxonomy_menu.database.inc');

/**
 * Implementation of hook_perm().
 */
function taxonomy_menu_perm() {
  return array('administer taxonomy menu');
}

/**
 * Implementation of hook_form_alter().
 *
 * Modify the form at admin/content/taxonomy/edit/vocabulary/xx. We add
 * our taxonomy_menu options in here on a per-vocab basis.
 */
function taxonomy_menu_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'taxonomy_form_vocabulary') {
    // choose a menu to add link items to.
    $options = menu_get_menus();
    array_unshift($options, '= DISABLED =');

    $form['taxonomy_menu'] = array(
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#title' => t('Taxonomy menu'),
      '#weight' => 10,
    );
    //this turns the vocab terms into menu items
    $form['taxonomy_menu']['vocab_enabled'] = array(
      '#type' => 'select',
      '#title' => t('Select menu'),
      '#default_value' => variable_get('taxonomy_menu_vocab_'. $form['vid']['#value'], FALSE),
      '#options' => $options,
      '#description' => t('With this option enabled, an entry will be created in the menu system for this vocabulary.')
    );
    $form['taxonomy_menu']['handlers'] = array(
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#title' => t('Advanced Handlers'),
      '#collapsed' => TRUE,
      '#description' => t('Change what functions process the creation of the menu link.'),
    );
    //set the handler for the path
    $form['taxonomy_menu']['handlers']['handler_path'] = array(
      '#type' => 'select',
      '#title' => t('Path Handler'),
      '#default_value' => variable_get('taxonomy_menu_handler_path_'. $form['vid']['#value'], 'taxonomy_menu_handler_default'),
      '#options' => _taxonomy_menu_get_handlers('path'),
    );
    //set the handler for insert
    $form['taxonomy_menu']['handlers']['handler_insert'] = array(
      '#type' => 'select',
      '#title' => t('Insert Handler'),
      '#default_value' => variable_get('taxonomy_menu_handler_insert_'. $form['vid']['#value'], 'taxonomy_menu_handler_default'),
      '#options' => _taxonomy_menu_get_handlers('insert'),
    );
    //set the handler for update
    $form['taxonomy_menu']['handlers']['handler_update'] = array(
      '#type' => 'select',
      '#title' => t('Update Handler'),
      '#default_value' => variable_get('taxonomy_menu_handler_update_'. $form['vid']['#value'], 'taxonomy_menu_handler_default'),
      '#options' => _taxonomy_menu_get_handlers('update'),
    ); 
    //set the handler for delete
    $form['taxonomy_menu']['handlers']['handler_delete'] = array(
      '#type' => 'select',
      '#title' => t('Delete Handler'),
      '#default_value' => variable_get('taxonomy_menu_handler_delete_'. $form['vid']['#value'], 'taxonomy_menu_handler_default'),
      '#options' => _taxonomy_menu_get_handlers('delete'),
    );
    //options fieldset
    $form['taxonomy_menu']['options'] = array(
      '#type' => 'fieldset',
      '#title' => t('Options'),
      '#collapsible' => TRUE,
    );
    //syncronise the changes.  best to leave this one.
    $form['taxonomy_menu']['options']['vocab_sync'] = array(
      '#type' => 'checkbox',
      '#title' => t('Syncronise changes to this vocabulary'),
      '#default_value' => variable_get('taxonomy_menu_sync_'. $form['vid']['#value'], TRUE),
      '#description' => t('Every time a term is added/deleted/modified, the corresponding menu link will be altered too.'),
    );
    //add the number of nodes attached to the term
    $form['taxonomy_menu']['options']['vocab_item_num'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display Number of Nodes'),
      '#default_value' => variable_get('taxonomy_menu_display_num_'. $form['vid']['#value'], FALSE),
      '#description' => t("Dipslay the number of Items per taxonomy Terms.  Will not show up for vocabulary menu items."),
    );
    //menu item for the vocabulary
    $form['taxonomy_menu']['options']['vocab_item_enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Item for Vocabulary'),
      '#default_value' => variable_get('taxonomy_menu_voc_item_'. $form['vid']['#value'], TRUE),
      '#description' => t("Shall the vocabulary have it's own item"),
    );
    //auto expand the menu
    $form['taxonomy_menu']['options']['expanded'] = array(
      '#type' => 'checkbox',
      '#title' => t('Auto Expand Menu Item'),
      '#default_value' => variable_get('taxonomy_menu_expanded_'. $form['vid']['#value'], TRUE),
      '#description' => t('Sets the expand setting to TRUE'),
    );
    //rebuild the menu
    $form['taxonomy_menu']['options']['rebuild'] = array(
      '#type' => 'checkbox',
      '#title' => t('Select to rebuild the menu on submit.'),
      '#default_value' => 0,
      '#description' => t('Rebuild the menu on submit.  Warning:  This will delete create all of the menu items.  Only use this option if you are experiencing issues.'),
    );
    // move the buttons to the bottom of the form
    $form['delete']['#weight'] = 49;
    $form['submit']['#weight'] = 50;
    
    // add an extra submit handler to save these settings
    $form['#submit'][] = 'taxonomy_menu_vocab_submit';
    
  }
}

/**
 * Submit handler for the extra settings added to the taxonomy vocab form.
 *
 * Check to see if the user has selected a different menu, and only rebuild
 * if this is the case.
 */
function taxonomy_menu_vocab_submit($form, &$form_state) {
  $vid = $form_state['values']['vid'];
  
  $old_menu = variable_get('taxonomy_menu_vocab_'. $vid, '0');
  $new_menu = $form_state['values']['vocab_enabled'];
  
  // syncronisation option
  variable_set('taxonomy_menu_sync_'. $vid, $form_state['values']['vocab_sync']);
  
  // view item option
  variable_set('taxonomy_menu_voc_item_'. $vid, $form_state['values']['vocab_item_enabled']);
  variable_set('taxonomy_menu_display_num_'. $vid, $form_state['values']['vocab_item_num']);
  variable_set('taxonomy_menu_expanded_'. $vid, $form_state['values']['expanded']);
  
  // set handlers
  variable_set('taxonomy_menu_hanlder_path'. $vid, $form_state['values']['handler_path']);
  variable_set('taxonomy_menu_hanlder_insert'. $vid, $form_state['values']['handler_insert']);
  variable_set('taxonomy_menu_hanlder_update'. $vid, $form_state['values']['handler_update']);
  variable_set('taxonomy_menu_hanlder_delete'. $vid, $form_state['values']['handler_delete']);
  
  variable_set('taxonomy_menu_vocab_'. $vid, $new_menu);
  // only rebuild if the menu option has changed.
  if ($form_state['values']['rebuild'] || $old_menu == 0) {
    _taxonomy_menu_rebuild_link_items($vid, FALSE);
  }
  else {
    _taxonomy_menu_rebuild_link_items($vid, TRUE);    
  }
}

/**
 * Implementation of hook_taxonomy().
 *
 * When a user inserts, alters or deletes taxonomy terms, we can keep
 * the related menu synchronised to the changes without rebuilding the entire
 * menu (which would delete all other customisations the user may have done).
 */
function taxonomy_menu_taxonomy($op, $type, $args = NULL) {
  //if submiting vocab, set new preferences
  
  if ($type == 'vocabulary') {
    if ($op == 'delete') {
      _taxonomy_menu_delete_all($vid);
      // rebuild the menu
      $menu_name = variable_get('taxonomy_menu_vocab_'. $args['vid'], 0);
      menu_cache_clear($menu_name);      
    }    
  }
  else {
    // only sync if taxonomy_menu is enabled for this vocab and the 'sync'
    // option has been checked.
    $menu_name = variable_get('taxonomy_menu_vocab_'. $args['vid'], 0);
    $sync = variable_get('taxonomy_menu_sync_'. $args['vid'], 0);
  
    if ($type == 'term' && $menu_name && $sync) {
      //build arugments
      switch ($op) {
        case 'insert':   
          //we have to pull from the args because using a taxonomy function pulls from the cache
          $term->name = $args['name'];
          $term->description = $args['description'];
          $term->parents = $args['parent'];
          $term->weight = $args['weight'];
          $term->vid = $args['vid'];
          $term->tid = $args['tid'];             
          $item = array(
            'term' => $term,
            'menu_name' => $menu_name,
          );
          $message = "Term '@term' has been added to taxonomy menu '@menuname'";
          break;
  
        case 'update':
          //we have to pull from the args because using a taxonomy function pulls from the cache
          $term->name = $args['name'];
          $term->description = $args['description'];
          $term->parents = $args['parent'];
          $term->weight = $args['weight'];
          $term->vid = $args['vid'];
          $term->tid = $args['tid'];
          $item = array(
            'term' => $term,
            'menu_name' => $menu_name,
            'mlid' => _taxonomy_menu_get_mlid($args['tid'], $args['vid']),
          );
          $message = "Term '@term' has been updated in taxonomy menu '@menuname'";
          break;
  
        case 'delete':
          $item = array(
            'tid' => taxonomy_get_term($args['tid']),
            'mlid' => _taxonomy_menu_get_mlid($args['tid'], $args['vid']),
          );
          $message = "Term '@term' has been deleted from taxonomy menu '@menuname'";
          break;
      }
      //run funtion
      taxonomy_menu_hanlder($op, $item);
      // report status
      $message = t($message, array('@term' => $args['name'], '@menuname' => $menu_name));
      drupal_set_message($message, 'status');
  
      // rebuild the menu
      menu_cache_clear($menu_name);
    }
  }
}

/**
 * Remove all menu links for a given vocab and rebuild it completely.
 * 
 * @param $vid vocab id
 * @param $update 
 *  if set to true, then delete all menu records then rebuild
 *  if set to false, then just update the menu items
 */
function _taxonomy_menu_rebuild_link_items($vid, $update = TRUE) {
  // rebuild vocab 'taxonomy_menu_voc_item_' . $vid
  $menu_name = variable_get('taxonomy_menu_vocab_'. $vid, FALSE);
  $voc_item = variable_get('taxonomy_menu_voc_item_'. $vid, FALSE);
    
  //if update is true then save the existing menu items with the new menu
  if (!$update) {
    _taxonomy_menu_delete_all($vid);
  }
  
  //only if the a menu name is set
  if ($menu_name) {
    //if supposed to add a vocab item then add it here
    if ($voc_item) {
      $args = array(
        'vid' => $vid,
        'menu_name' => $menu_name,
      );
      
      //if rebuilding all then run the insert handler
      if (!$update) {
        $mlid = taxonomy_menu_hanlder('insert', $args);
      }
      //if updaet then get the mlid and update the menu items
      else {
        $args['mlid'] = _taxonomy_menu_get_mlid(0, $vid);
        taxonomy_menu_hanlder('update', $args);
      }
    }
    
    //cycle through terms for the vocab
    foreach (taxonomy_get_tree($vid) as $term) {
      $args = array(
        'term' => $term,
        'menu_name' => $menu_name,
      );
      
      //if rebuilding all then run the insert handler
      if (!$update) {
        $mlid = taxonomy_menu_hanlder('insert', $args);
      }
      //if updaet then get the mlid and update the menu items
      else {
        $args['mlid'] = _taxonomy_menu_get_mlid($term->tid, $vid);
        taxonomy_menu_hanlder('update', $args);        
      }
      
    }
    variable_set('menu_rebuild_needed', TRUE);
    drupal_set_message(t('The taxonomy menu has been rebuilt.'), 'status');
  }
  else {
    // no menu name is specified, so user has selected = DISABLED = from
    // the taxonomy vocab form.
    _taxonomy_menu_delete_all($vid);
    //full menu rebuild is needed when deleting all of the items
    variable_set('menu_rebuild_needed', TRUE);
    drupal_set_message(t('The taxonomy menu has been disabled.'), 'status');
  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * This hook enables the menu to be displayed in context during node views.
 */
function taxonomy_menu_nodeapi(&$node, $op, $a3, $a4) {
  static $old_terms;
  
  //if display numbers is on the update the menu item with the new name
  if ($op == 'update' || $op == 'insert' || $op == 'delete') {
    //get the terms from the node.
    $terms = $node->taxonomy;
    $terms = array_merge((array)$terms, (array)$old_terms);
    foreach ($terms as $key => $tid) {
      $term = taxonomy_get_term($tid);
      //update the menu for each term if necessary
      $menu_name = variable_get('taxonomy_menu_vocab_'. $term->vid, FALSE);
      $vocb_sync = variable_get('taxonomy_menu_sync_'. $term->vid, TRUE);
      $menu_num = variable_get('taxonomy_menu_display_num_' , $term->vid, FALSE);
      
      if ($menu_name && $vocb_sync && $menu_num) {
        switch ($op) {
          case 'update':
            //build argument array to save menu_item
            $args = array(
              'term' => $term,
              'menu_name' => $menu_name,
              'mlid' => _taxonomy_menu_get_mlid($term->tid, $term->vid),
            );
            //since taxonomy_get_term does not return the parents, fetch them now
            $args['term']->parents = _taxonomy_menu_get_parents($term->tid);            
            break;
            
          case 'insert':
            //build argument array to save menu_item
            $args = array(
              'term' => $term,
              'menu_name' => $menu_name,
            );
            //since taxonomy_get_term does not return the parents, fetch them now
            $args['term']->parents = _taxonomy_menu_get_parents($term->tid);
            break;
            
          case 'delete':
            $args = array(
              'tid' => $term->tid,
              'mlid' => _taxonomy_menu_get_mlid($term->tid, $term->vid),
            ); 
        }
        taxonomy_menu_hanlder($op, $args);
      }
    }
  }
  elseif ($op == 'presave') {
    //get the terms from the database before the changes are made.
    //these will be used to update the menu item's name if needed
    //we go directly to the db to bypass any caches
    $old_terms = _taxonomy_menu_get_node_terms($node->nid);
  }
}

/**
 * Provide a list of taxonomy_menu handlers
 *
 * @param $op
 *   'path' => return value will contain path handlers
 *   'insert' => add a vaule to the menu
 *   'update' => updated a menu link
 *   'delete' => detete a menu link
 * @param $item
 *  if $op == 'insert' then
 *    array with the following key/value pairs:
 *     'tid' => the term id (if 0 then adding the vocab as an item)
 *     'name' => the term's name
 *     'description' => term description, used as to build the title attribute
 *     'weight' => term weight
 *     'vid' => the vocabulary's id
 *     'ptid' => the term's parent's term id.  use 0 for vocab
 *     'menu_name' => the menu that the link item will be inserted into
 *  if $op == 'delete' then array('tid' => TermID) OR ('link_path' => path to menu item)
 *  if $op == 'update' then
 *    array with the following key/value pairs:
 *     'tid' => the term id (if 0 then updating the vocab as an item)
 *     'name' => new menu name
 *     'description' => new menu description, used as to build the title attribute
 *     'weight' => new menu weight
 *     'vid' => the new vocabulary's id
 *     'ptid' => the new parend tid
 *
 * @return
 *   - $op == 'path' - An array containing handler functions as keys
 *   - $op == 'insert' - New mlid
 */
function hook_taxonomy_menu_handlers($op) {
  return array(
    'taxonomy_menu_handler_default' => t('Default'),
  );
}

/**
 * HANDLING
 * Invokes hook_taxonomy_menu_item
 * 
 * @param $op
 *  options are 'update', 'delete', 'insert', 'path
 *  
 * @param $args
 *  if $op == 'insert' then
 *    array with the following key/value pairs:
 *     'term' => term object,
 *     'menu_name' => menu that the item is set to apply to
 *  if $op == 'delete' then 
 *    array(
 *      'tid' => TermID
 *      'mlid => Menu ID
 *    ) 
 *  if $op == 'update' then
 *     'term' => term object,
 *     'menu_name' => menu that the item is set to apply to
 *     'mlid' =? Menu ID
 *  if $op == 'path' then  ONLY SEND ONE of the three
 *    'term' => term object OR tid OR vid
 *    'tid' => termID
 *    'vid' => vocabID
 */
function taxonomy_menu_hanlder($op, $args = array()) {
  
  //get the vid from the arguments
  if (is_object($args['term'])) {
    $vid = $args['term']->vid;
  }
  elseif (!empty($args['term'])) {
    $vid = $args['term']['vid'];
  }
  elseif (!empty($args['vid'])) {
    $vid = $args['vid'];
  }
  elseif (!empty($args['tid'])) {
    $t = taxonomy_get_term($term);
    $vid = $t->vid;
  }
  
  //get the handler for the selected vocab
  $handler = variable_get('taxonomy_menu_handler_'. $op .'_'. $vid, 'taxonomy_menu_handler_default');
  if (!function_exists($handler)) {
    $handler = 'taxonomy_menu_handler_default';
  }
  
  $item = $handler($op, $args);
  
  //if looking for the path then return the path, otherwise run the other handler function
  if ($op != 'path') {
    return _taxonomy_menu_item($item);
  }
  else {
    return $item;
  } 
}

/**
 * Helper function to get a list of the handlers
 * Uses drupal caching
 * 
 * @param $op 
 *  'path' or 'insert' or 'delete' or 'update'
 * @return handlers for method
 */
function _taxonomy_menu_get_handlers($op) {
  $handlers = cache_get('taxonomy_menu_cache_'. $op, 'cache');
  
  if (!$handlers) {
    $handlers = module_invoke_all('taxonomy_menu_handlers', $op);
    cache_set('taxonomy_menu_cache_'. $op, $handlers);
  }
  
  return $handlers;
}

/**
 * Add/Update a taxonomy menu item.
 *
 * We use a custom data array $item as a parameter, instead of using a
 * standard taxonomy $term object. This is because this function is also
 * called from hook_taxonomy(), which doesn't have a $term object. Rather
 * have one consistent method of passing the data.
 *
 * @param $item
 *   array with the following key/value pairs:
 *     'tid' => the term id (if 0 then adding the vocab as an item)
 *     'name' => the term's name
 *     'description' => term description, used as to build the title attribute
 *     'weight' => term weight
 *     'vid' => the vocabulary's id
 *     'ptid' => the term's parent's term id
 *     'menu_name' => the menu that the link item will be inserted into
 *     'mlid' => if this is filled in then the mlid will be updated
 */
function _taxonomy_menu_item($item) {
  // Calculate the number of children nodes
  $num = taxonomy_term_count_nodes($item['tid']);
  $insert = TRUE;
  
  // If the number of children nodes of this term is zero and the
  // 'Hide Empty Terms' option is enabled, don't create the menu item.
  if (!($num == 0 && variable_get('taxonomy_menu_hide_empty', FALSE))) {
    // option to display the number of associated nodes

    //if the ptid is 0 and there should be a vocab menu item then set the parent to the vocab menu item
    $voc_item = variable_get('taxonomy_menu_voc_item_'. $term->vid, 0);
    
    if ($item['ptid'] == 0 && $voc_item) {
      $ptid = _taxonomy_menu_get_mlid(0, $term['vid']);
    }
          
    $link = array(
      'link_title' => $item['name'],
      'menu_name' => $item['menu_name'],
      'plid' => _taxonomy_menu_get_mlid($item['ptid'], $item['vid']),
      'options' => array('attributes' => array('title' => t($item['description']))),
      'weight' => $item['weight'],
      'module' => 'taxonomy_menu',
      'expanded' => variable_get('taxonomy_menu_expanded_'. $item['vid'], TRUE),
    );
    
    //build path.
    if ($item['path_type']) {
      $args = array(
        $item['path_type'] => $item[$item['path_type']],
      );
      $link['link_path'] = taxonomy_menu_hanlder('path', $args);
    }
    
    //only disply numbers for terms, not vocabulary
    if ($item['tid'] != 0 && variable_get('taxonomy_menu_display_num_'. $item['vid'], FALSE)) {
        $link['link_title'] .= " ($num)";
    }
    
    //if pased a mlid then add it
    if ($item['mlid']) {
      $link['mlid'] = $item['mlid'];
      $insert = FALSE;
    }
    
    //set the has_children property
    //if tid=0 then adding a vocab item and had children
    //if the term has any children then set it to true
    if ($item['tid'] == 0) {
      $link['has_children'] = 1;
    }
    else {
      $children = taxonomy_get_children($item['tid']);
      if (!empty($children)) {
        $link['has_children'] = 1;
      }      
    }    
    
    //save the menu item
    if ($mlid = menu_link_save($link)) {
      //if inserting a new menu item then insert a record into the table
      if ($insert) {
        _taxonomy_menu_insert_menu_item($mlid, $item['tid'], $item['vid']);
      }
      return $mlid;
    }
    else {
      drupal_set_message(t('Could not save the menu link for the taxonomy menu'), 'error');
      return FALSE;
    }
  }
}
